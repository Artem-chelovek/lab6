# Вариант 4. 0-1 Рюкзак с жадным алгоритмом
## **1. Определение алгоритма**
Жадный 2‑аппроксимационный алгоритм для 0‑1 рюкзака — это приближённый алгоритм, который:
На каждом шаге выбирает предмет с наибольшим отношением стоимости к весу (удельной стоимостью:стоимость/вес).
Добавляет предмет в рюкзак, если его вес не превышает оставшуюся вместимость.
Завершает работу, когда больше ни один предмет нельзя добавить.

***Почему «2‑аппроксимационный»?***
Алгоритм гарантирует, что найденное решение будет не хуже половины оптимального (т. е. результат≥ 1/2⋅OPT(I)). Это следует из того, что:

- Либо жадный выбор даёт хороший результат.
- Либо один самый ценный предмет (по стоимости) уже даёт не менее половины OPT.

Поэтому в улучшенном варианте алгоритма мы сравниваем жадное решение и самый ценный отдельный предмет — и выбираем лучшее из двух.
## **2. Анализ алгоритма** 
Принцип работы алгоритма (по шагам)
### 1. Сортировка по удельной стоимости
- Строка: `sorted(items, key=lambda x: x['value'] / x['weight'], reverse=True)`
- Суть: предметы упорядочиваются по соотношению «стоимость / вес» (чем выше — тем «выгоднее»).
- Зачем: жадный выбор — брать сначала самые «эффективные» предметы.

### 2. Жадный проход
- Цикл: `for item in sorted_items: ...`
- Суть: по порядку проверяем, помещается ли предмет в рюкзак. Если да — добавляем.
- Результат: набор предметов с высокой удельной стоимостью, уложенных «до заполнения».

### 3. Поиск самого ценного предмета
- Цикл: `for item in items: ...`
- Суть: находим предмет с максимальной стоимостью, который влезает в рюкзак.
- Зачем: в некоторых случаях один дорогой предмет лучше набора из нескольких.

### 4.Выбор лучшего решения
- Условие: `if total_value_greedy >= best_single_value: ...`
- Суть: сравниваем два варианта — жадный набор и один предмет. Берём тот, где стоимость выше.
- Гарантия: результат будет не хуже половины оптимального (≥ 0.5 · OPT).

### 5. Возврат результата
- Возвращаем список выбранных предметов, их общую стоимость и гарантированный коэффициент аппроксимации.



## **3. Оценка временной сложности** 
**Итоговая временная сложность:**
O(nlogn)

**Пояснение:**
- Основной вклад даёт сортировка (nlogn).
- Остальные шаги линейны по n.

## **4. Обоснование оценки временной сложности**
### Обоснование по шагам:
1. Сортировка
    Операция: `sorted(...)`
    Сложность: O(nlogn)
    Почему: стандартная сортировка сравнением (например, Timsort в Python) имеет такую асимптотику.
2. Жадный проход
    Операция: `цикл по sorted_items`
    Сложность: O(n)
    Почему: один проход по списку из n элементов.
3. Поиск самого ценного предмета
    Операция: `цикл по items`
    Сложность: O(n)
    Почему: ещё один проход по n элементам.

4. Сравнение и возврат
    Операция: условная проверка и присваивание
    Сложность: O(1)
    Почему: константное время.

**Итоговая сложность:**

O(nlogn)+O(n)+O(n)+O(1)=O(nlogn)

Доминирование: сортировка (O(nlogn)) «перевешивает» линейные проходы (O(n)), поэтому общая сложность определяется ею.

## **5. Ответ на контрольный вопрос**
***Контрольный вопрос №4. Жадный алгоритм для вершинного покрытия.***
***Почему жадный алгоритм для задачи о вершинном покрытии дает 2-аппроксимацию?***
***Приведите доказательство.***


Жадный алгоритм для задачи о вершинном покрытии, который на каждом шаге выбирает вершину с максимальной степенью и добавляет её в покрытие, не гарантирует 2-аппроксимацию. Однако существует другой алгоритм, который обеспечивает 2-аппроксимацию, и его можно ошибочно назвать «жадным» из-за простоты реализации. Этот алгоритм основан на нахождении максимального паросочетания в графе.

### Алгоритм с 2-аппроксимацией
**Алгоритм работает следующим образом:**
- 1.Найдите максимальное по включению паросочетание M в графе G
- 2.Пусть S — множество вершин, инцидентных рёбрам в M.
- 3.Верните S в качестве вершинного покрытия.

**Доказательство 2-аппроксимации:**
- Паросочетание и вершинное покрытие: Любое вершинное покрытие должно содержать по крайней мере одну вершину для каждого ребра в паросочетании M. Поскольку рёбра в M не имеют общих вершин, число вершин в минимальном покрытии OPT не может быть меньше числа рёбер в M: OPT≥∣M∣.

- Размер покрытия S: Множество S содержит по две вершины для каждого ребра в M, поэтому ∣S∣=2∣M∣.

- Аппроксимация: Так как ∣M∣≤OPT, то ∣S∣=2∣M∣≤2⋅OPT. Следовательно, алгоритм гарантирует, что размер покрытия не превышает удвоенный размер оптимального решения.

Таким образом алгоритм даёт покрытие не более чем в 2 раза хуже оптимального — это и есть 2-аппроксимация.

