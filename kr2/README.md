# Вариант 19.Колония муравьёв для задачи о рюкзаке
***Условие.*** Решить задачу о рюкзаке (0‑1) с помощью алгоритма муравьиной колонии (ACO):
построить маршруты «муравьёв» как наборы предметов, максимизируя ценность при
ограничении по весу.
***Алгоритм:*** ACO с феромонами на рёбрах «предмет → предмет» и правилом выбора предмета
по удельной ценности и феромону.
## **1. Определение алгоритма**
Алгоритм муравьиной колонии строит для каждого муравья последовательность предметов (маршрут) путём стохастического выбора допустимых предметов с вероятностями, зависящими от феромона на рёбрах и удельной ценности (value/weight), затем испаряет феромон и усиливает рёбра, участвовавшие в хороших решениях; повторяет это заданное число итераций и возвращает лучшее найденное сочетание предметов.

## **2. Описание алгоритма пошагово + строковая иллюстрация для каждого шага**
Ключевые 6 шагов ACO для 0-1 рюкзака

**1.Инициализация размеров и феромонов**

`n = len(weights); pheromone = [[1.0 for _ in range(n)] for _ in range(n)]`
Пояснение: фиксируем число предметов n и создаём матрицу феромонов n×n со стартовым значением (начальные «знания»).

**2.Цикл итераций ACO**

`for it in range(n_iter):`
Пояснение: основной внешний цикл — повторяем процедуру построения решений и обновления феромонов заданное число итераций для накопления и усиления хороших маршрутов.

**3.Построение решения одного муравья — допустимые кандидаты**

`feasible = [j for j in range(n) if j not in solution and total_weight + weights[j] <= W]`
Пояснение: на каждом шаге для данного муравья формируем список предметов, ещё не взятых и помещающихся по оставшемуся весу — из них будем выбирать дальше.

**4.Оценка кандидатов и стохастический выбор**
`scores = [(pheromone[current_item][j]**alpha) * ((values[j]/weights[j])**beta) for j in feasible]; probs = [s/sum(scores) for s in scores]`
Пояснение: вычисляем для каждого допустимого предмета оценку τ^α·η^β (фактор феромона × эвристика) и нормируем в вероятности — затем по этим вероятностям выбираем элемент (рулетка).

**5.Испарение феромонов (снижение влияния старых решений)**
`pheromone[i][j] *= (1 - rho)`
Пояснение: уменьшаем феромоны на всех рёбрах, чтобы предотвращать бесконечный рост и давать шанс новым альтернативам.

**6.Усиление феромонов по лучшему решению и обновление глобального лучшего**
`for k in range(len(iter_best_sol)-1): `
Пояснение: депонируем феромон вдоль переходов лучшего решения текущей итерации (чтобы увеличить шанс повторения хороших комбинаций) и при необходимости обновляем глобально лучший найденный набор.




## **3. Временная сложность:**
Время выполнения одного полного цикла состоит из нескольких этапов:

***Выбор предмета (формула расчета вероятностей):*** на каждом шаге требуется вычислить сумму по всем доступным предметам, что ведет к O(I) операций на каждый шаг, где I — количество предметов.

***Один полный проход муравья:*** проходит по всем доступным предметам, проверяя и принимая решения, что также дает O(I) на каждого муравья.
Полный цикл по всем муравьям: умножаем на количество муравьев, получаем O(I⋅A), где A — количество муравьев.

***Обновление феромонов:*** после каждой итерации для всех решений муравьев потребуется O(n^2) операций, так как феромоны обновляются на уровне всей матрицы.
Суммарно, учитывая все циклы и процессы, временная сложность составит: O(I⋅A⋅n^2),
где:
I — количество предметов,
A — количество муравьев,
n — количество предметов.
## **4. Почему такая временная сложность?**
Вычисление вероятностей — это самая ресурсоемкая часть, так как она предполагает суммирование по всем доступным предметам, что дает O(I) на каждом шаге.

**Прохождение муравья** — каждый муравей последовательно рассматривает все доступные предметы, что дает 
O(I) на муравья.
**Обновление феромонов** — требуется обновлять матрицу феромонов целиком, что также дает 
O(n^2) операций.

Поскольку обе операции выполняются многократно в течение всех итераций и для всех муравьев, итоговая временная сложность возрастает экспоненциально от количества итераций, муравьев и количества предметов.

## **5. Контрольный вопрос №19. Какой компромисс существует между точностью приближенного алгоритма и скоростью его
работы?**
Суть компромисса

Более высокая точность требует большего количества вычислений, времени и ресурсов.

Более высокая скорость достигается за счёт упрощений, которые обычно снижают точность результата.

Иными словами: чем быстрее работает приближённый алгоритм, тем, как правило, менее точным он становится; чем точнее — тем медленнее.

**Почему это происходит**

Приближённый алгоритм отказывается от полного перебора или глубокого поиска.

Чтобы повысить точность, он должен:
- выполнять больше итераций,
- рассматривать больше вариантов решений,
- дольше искать улучшения.

Если же целью является скорость, алгоритм:
- использует меньше итераций,
- меньше пробует альтернатив,
- быстрее принимает решения (часто жадным образом),
- снижает сложность модели.

Это уменьшает время работы, но ухудшает качество результата.

Пример: муравьиный алгоритм для задачи о рюкзаке

Точность растёт, если:
- увеличить число муравьёв — больше перебирается комбинаций
- увеличить число итераций — муравьи дольше ищут оптимум
- уменьшить скорость испарения — сохраняется больше информации о хороших путях.

Но всё это увеличивает время работы.

Универсальное правило:
**Приближённые методы — это баланс между «быстро, но грубо» и «медленно, но лучше».**

Настройка алгоритма зависит от задачи:
- если задача большая → выбирают скорость в ущерб точности,
- если точность критична → увеличивают время вычислений.