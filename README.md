##**Определение метода Shell Sort:**

Shell Sort — это расширение сортировки вставками, разработанное Дональдом Шеллом, которое уменьшает количество сравнений и обменов путём выполнения предварительных «групповых» сортировок с постепенным уменьшением интервала между сравниваемыми элементами.

---

**Основные идеи и шаги алгоритма:**

1. Выбрать начальный интервал (gap), который обычно берётся как часть последовательности (например, \(n/2\), \(n/4\), ..., 1).
2. Выполнить сортировку вставками для элементов, расположенных через интервал gap.
3. Постепенно уменьшать интервал до 1.
4. В конце — выполнить обычную сортировку вставками, которая уже будет работать почти отсортированным массивом.

---

**Работа алгоритма:**

- На первом этапе сортируются элементы, разобранные по группам через выбранный интервал.
- Эти предварительные упорядочивания помогают «распутывать» массив, уменьшая количество необходимых обменов при финальной сортировке.
- В итоге, когда интервал равен 1, массив уже почти отсортирован, и последняя проходка выполняется очень быстро.

---

**Анализ временной сложности:**

- В худшем случае, например, при плохо подобранных интервалах или неэффективных последовательностях, сложность может достигать \( O(n^2) \).

- Однако в практике, при разумном выборе интервалов, Shell Sort показывает хорошую производительность и обычно работает за приблизительно \( O(n^{1.3}) \) или \( O(n^{1.5}) \).

- **Некоторые последовательности интервалов (паттерны):**
  - Простая: \( \text{gap} = n/2, n/4, \dots, 1 \)
  - Гораздо более эффективные: последовательность Шелла (непрерывное деление на 2), С-кармановская, и др.

---

**Итоговая оценка сложности:**

| Ситуация                         | Временная сложность                         |
|----------------------------------|--------------------------------------------|
| В среднем и худшем случае       | примерно \( O(n^{1.3} - n^{1.5}) \)      |
| В лучшем случае                   | \( O(n \log^2 n) \) (при правильных интервалах) |

---

**Краткое резюме:**

- Shell Sort — улучшение сортировки вставками с использованием интервалов.
- Быстрее сортировки вставками в среднем случае.
- Прост в реализации и использует немного дополнительной памяти.
- Эффективен для средних размеров массивов, однако лучше подходит для практических задач, чем для очень больших данных, из-за сложности определения оптимальной последовательности интервалов.

##**Определение метода HeapSort:**

HeapSort — это эффективный алгоритм сортировки, основанный на структуре данных «куча» (heap). Он сначала преобразует исходный массив в структуру кучи (обычно в max-кучу для сортировки по возрастанию), а затем последовательно извлекает максимум, помещая его в конец массива и восстанавливая свойства кучи после каждого извлечения.

---

**Основные шаги алгоритма:**

1. Построить кучу из массива (преобразовать массив в max-heap).
2. Вынуть корень кучи (максимальный элемент) — он становится последним элементом массива.
3. Уменьшить размер кучи и восстановить её свойства (heapify).
4. Повторять шаги 2-3 до тех пор, пока куча не станет пустой.

---

**Анализ временной сложности HeapSort:**

- **Построение кучи:**

Преобразование массива в кучу выполняется за \( O(n) \). Это связано с тем, что операция heapify для внутренних узлов запускается в порядке снизу вверх, делая всю процедуру-linear по времени.

- **Процесс сортировки:**

После построения кучи, каждый из \( n \) элементов извлекается по одному, а после каждого извлечения восстанавливается структура кучи (heapify), что занимает \( O(\log n) \).

Общая сложность этого этапа:

\[ T(n) = n \times O(\log n) = O(n \log n) \]

- **Общий итог:**

Объединяя оба этапа, получаем:

\[ O(n) + O(n \log n) = O(n \log n) \]

---

**Почему именно такая оценка:**

- Построение кучи — \( O(n) \).
- Последовательные операции извлечения максимума и перестраивания кучи — \( O(\log n) \) на каждый из \( n \) элементов.
- В совокупности это даёт квадратично-логарифмическую сложность — не хуже, чем у быстрой сортировки, и, в отличие, не зависит от выбора опорных элементов.

---

**Итоговая таблица сложности HeapSort:**

| Ситуация          | Временная сложность             |
|------------------|---------------------------------|
| В среднем, худшем и лучшем случаях | \( O(n \log n) \) |

---

**Дополнительные особенности:**

- HeapSort — это стабильный и неустранимо-непрерывный алгоритм.
- Он использует больше места, чем сортировка в‑place (требует дополнительного места для хранения кучевой структуры, обычно реализуется на месте).
- Он гарантирует равную временную сложность независимо от исходного порядка элементов.

##**Определение метода Merge Sort (сортировка слиянием):**

Merge Sort — это эффективный алгоритм сортировки, основанный на принципе «разделяй и властвуй». Он рекурсивно разбивает исходный массив на две половины, сортирует каждую из них отдельно, а затем объединяет отсортированные части в один отсортированный массив.

---

**Основные шаги алгоритма:**

1. Разделить массив на две примерно равные части.
2. Рекурсивно применить Merge Sort к каждой части.
3. Объединить две отсортированные половины в один отсортированный результат (слияние).

---

**Анализ временной сложности Merge Sort:**

- **Построение рекурсии:**

Массив делится пополам каждый раз, число уровней рекурсии равно примерно \( \log_2 n \).

- **Объединение двух отсортированных частей:**

На каждом уровне рекурсии осуществляется процесс слияния, который требует \( O(n) \) времени для объединения всей части массива.

- **Общая сложность:**

Так как уровни рекурсии — \( O(\log n) \), а на каждом уровне требуется \( O(n) \) времени для объединения, итоговая временная сложность будет:

\[ T(n) = O(n \log n) \]

- **Подробно:**

На каждом уровне разбиения в сумме обрабатывается весь массив (в процессе слияния), а так как уровней всего \( \log n \), итоговая сложность:

\[ O(n \log n) \]

---

**Почему именно такая оценка:**

- Деление массива — очень быстрый процесс, практически \( O(\log n) \) уровней.
- Объединение (слияние) двух отсортированных частей — линейное по размеру массива на каждом уровне.
- Итог: сложность \( O(n \log n) \) для средних, худших и лучших случаев.

---

**Итоговая таблица сложности Merge Sort:**

| Ситуация          | Временная сложность             |
|------------------|---------------------------------|
| Лучший, средний и худший случаи | \( O(n \log n) \) |

---

**Дополнительные особенности:**

- Merge Sort — стабильный алгоритм (сохраняет порядок равных элементов).
- Он требует дополнительной памяти примерно \( O(n) \), чтобы выполнять слияния.
- Эффективен для очень больших массивов и для данных, которые плохо управляются при in-place сортировках.

##**Определение метода Selection Sort (сортировка выбором):**

Selection Sort — это простой алгоритм сортировки, который последовательно выбирает минимальный элемент из несортированной части массива и помещает его в начало этой части. Этот процесс повторяется для каждого следующего элемента, постепенно расширяя отсортированную область.

---

**Основные шаги алгоритма:**

1. Начинается с первого элемента массива.
2. В оставшейся части массива находит минимальный элемент.
3. Меняет местами этот минимальный элемент с первым элементом текущего окна.
4. Продвигается на следующий элемент и повторяет процесс, пока весь массив не будет отсортирован.

---

**Анализ временной сложности Selection Sort:**

- **Процесс поиска минимального элемента:**

Для каждого из \( n \) элементов ищется минимальный среди оставшихся — это индекс и сравнения.

- Количество сравнений:

На первом шаге: сравниваем \( n-1 \) элементов.

На втором: сравниваем \( n-2 \) элементов.

И так далее, итого:

\[ (n-1) + (n-2) + \dots + 1 = \frac{(n-1)n}{2} = O(n^2) \]

- **Общая сложность:**

Всё время выполняется квадратично — независимо от начального порядка элементов.

**Пример:**

| Ситуация             | Временная сложность               |
|-----------------------|----------------------------------|
| Лучший, средний, худший случай | \( O(n^2) \) |

- В отличие от некоторых сортировок, выборочная сортировка не зависит от порядка элементов — её сложность одинаковая во всех случаях.

---

**Краткое резюме:**

- Прост в реализации.
- Не требует дополнительной памяти (in-place).
- Не стабильна (может менять порядок равных элементов).
- Неэффективна для больших массивов по сравнению с другими алгоритмами, такими как MergeSort или QuickSort, из-за квадратичной сложности.

##Определение метода QuickSort:

QuickSort — это эффективный алгоритм сортировки, основанный на методе «разделяй и властвуй». Он работает путём рекурсивного разбиения массива на две части по выбранному опорному элементу (пивоту), так чтобы элементы, меньшие пивота, оказались слева, а большие — справа. После разделения алгоритм рекурсивно сортирует обе части, пока массивы не станут полностью отсортированными.

Основные шаги алгоритма:

1.Выбрать опорный элемент.
2.Переставить элементы так, чтобы слева оказались меньшие или равные пивоту, а справа — большие.
3.Рекурсивно применить тот же процесс к левому и правому подмассивам.

Лучший и средний случаи:
Если выбранный пивот разбивает массив примерно на две равные части, то глубина рекурсии будет логарифмической, а на каждом уровне происходит линейная работа по перераспределению элементов.

Путём решения этого уравнения, например, методом мастер-теоремы, получаем:
O(n*log(n))
​
Худший случай:
Если опорный элемент выбирается неправильно и делит массив неравномерно (например, на 0 и n-1 элементы), то на каждой итерации остаётся почти весь массив, и глубина рекурсии становится линейной.

Так как тут два вложенных цикла for то это даёт сложность:
O(n^2) 


В среднем и в лучшем случае, благодаря равномерному делению, алгоритм работает очень быстро — O(n*log(n)).
В худшем случае, при неудачном выборе пивота, он превращается в сортировку вставками или пузырьковой — с квадратичной сложностью O(n^2)
Итог:

Ситуация	Временная сложность
Лучший случай	O(n*log(n))
Средний случай	O(n*log(n))
Худший случай	O(n^2)

##**Определение метода Insertion Sort (сортировка вставками):**

Insertion Sort — это простой алгоритм сортировки, основанный на последовательном построении отсортированной части массива. Он работает путём итеративного вставления каждого следующего элемента в уже отсортированную часть массива на правильную позицию, смещая остальные элементы при необходимости.

---

**Основные шаги алгоритма:**

1. Начинается с второго элемента массива (предполагается, что первый — уже отсортирован).
2. Для каждого элемента сравнивает его с элементами слева, пока не найдёт место для вставки.
3. Вставляет элемент в подходящую позицию, сдвигая оставшиеся элементы вправо.
4. Повторяет шаги для всех элементов массива.

---

**Анализ временной сложности Insertion Sort:**

- **Лучший случай:**

Если массив уже отсортирован или почти отсортирован, то внутри внешнего цикла сравнения практически не требуют перестановок, и алгоритм работает за линейное время.

- **Оценка:**

\[ T(n) = O(n) \]

поскольку проход по массиву и сравнения совершаются только один раз, без необходимости перемещать элементы.

- **Средний и худший случаи:**

Когда массив отсортирован в обратном порядке или случайным образом, нужно сдвигать элементы при каждом вставлении.

- В худшем случае, для каждого элемента требуется сравнить и переместить с каждым предыдущим элемент.

- **Оценка:**

\[ T(n) = O(n^2) \]

потому что внутренний цикл выполняется примерно 1, 2, ..., \( n-1 \) раз, то есть сумма арифметической прогрессии:

\[ 1 + 2 + \dots + (n-1) \approx \frac{n(n-1)}{2} = O(n^2) \]

---

**Почему именно такая оценка:**

- В худшем случае, каждый новый элемент сравнивается с уже отсортированными, и выполняется сдвиг элементов, что в совокупности даёт квадратичную сложность.
- В лучшем случае (уже отсортированный массив), сравнения и сдвиги не нужны, и алгоритм работает за \( O(n) \).

---

**Итоговая таблица сложности Insertion Sort:**

| Ситуация          | Временная сложность               |
|------------------|-----------------------------------|
| Лучший случай    | \( O(n) \)                      |
| Средний случай   | \( O(n^2) \)                    |
| Худший случай    | \( O(n^2) \)                    |

---

**Краткое резюме:**

Insertion Sort — хороший выбор для небольших или почти отсортированных массивов, так как он очень прост и при этом эффективен в этих случаях. Однако для больших или случайных массивов его эффективность уступает более сложным алгоритмам, таким как QuickSort или HeapSort.

##BubbleSort — это простейший алгоритм сортировки, основанный на последовательных сравнениях и обменах соседних элементов. Он многократно проходит по массиву, сравнивая пары соседних элементов и меняя их местами, если они расположены в неправильном порядке. Этот процесс повторяется до тех пор, пока весь массив не станет отсортирован.

Основные шаги алгоритма:

Проходить по массиву, сравнивать соседние элементы.
Если элементы расположены в неправильном порядке, поменять их местами.
После каждого полного прохода самый большой (или меньший) элемент «всплывает» в конец массива.
Повторять, пока не произойдут никакие обмены — массив полностью отсортирован.
Анализ временной сложности BubbleSort:

Лучший случай:
Если массив уже отсортирован, на первом проходе не произойдёт ни одного обмена, и алгоритм завершит работу за один проход.

Оценка:
T(n)=O(n)

Поскольку достаточно одного прохода по массиву, чтобы убедиться в его сортировке.

Средний и худший случаи:
В худшем случае, когда массив отсортирован в обратном порядке, алгоритм выполнит сравнения и обмены на каждом шаге для всех элементов, что даёт более сложную работу.

Оценка:
Во всех случаях, кроме оптимизированного варианта, количество сравнений и обменов — квадратное по порядку.

T(n)=O(n 
2
 )

Конкретно:

Перебирается каждый из n−1 элементов в первом проходе, далее n−2, ..., последний проход — 1. Это сумма арифметической прогрессии:
1+2+⋯+(n−1)≈ 
2n(n−1)=O(n^2)

Почему именно такая оценка:

В худшем и среднем случаях алгоритм делает наибольшее число сравнений и обменов — порядка n^2
В оптимизированной реализации (например, добавление флага для остановки, если во время прохода не было обменов) в лучшем случае он работает за O(n).
Итоговая таблица сложности BubbleSort:

Ситуация	Временная сложность
Лучший случай	O(n)
Средний случай	O(n^2)
Худший случай	O(n^2)
Обобщение:

BubbleSort — очень простой, но неэффективный алгоритм для больших массивов.
Его слабая сторона — квадратичная временная сложность в худшем случае и средней ситуации.
В практике используют его только для обучения или очень небольших массивов.