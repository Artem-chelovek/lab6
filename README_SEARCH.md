**Определение метода Linear Search (линейный поиск):**

Linear Search — это простой алгоритм поиска элемента в массиве, который последовательно просматривает каждый элемент, начиная с первого, пока не найдёт искомое значение или не достигнет конца массива.



**Основные шаги алгоритма:**

1. Начать с первого элемента массива.
2. Сравнить текущий элемент с искомым.
3. Если они совпадают — вернуть индекс найденного элемента.
4. Если не совпадают — перейти к следующему элементу.
5. Повторять до тех пор, пока не будет найден элемент или массив не закончится.
6. Если элемент не найден — вернуть отрицательный результат (например, -1).



**Анализ временной сложности:**

- **В лучшем случае:**

Если искомый элемент находится в начале массива, то поиск завершится за 1 сравнение.

\[ T_{\text{лучший}} = O(1) \]

- **В среднем и худшем случае:**

Если элемент находится в конце массива или отсутствует вовсе, придётся проверить все \( n \) элементов.

\[ T_{\text{средний}} = T_{\text{худший}} = O(n) \]

- **Итоговая сложность:**

| Ситуация                     | Временная сложность |
|--------------------------------|---------------------|
| Лучший случай (найден в начале) | \( O(1) \)        |
| Средний и худший случаи        | \( O(n) \)        |



**Краткое резюме:**

- Очень прост и легко реализуется.
- Неэффективен для больших массивов по сравнению с более сложными методами поиска (например, бинарным), так как требует линейного времени.
- Подходит для небольших массивов или когда структура данных не позволяет применять более быстрые алгоритмы.


---


**Определение метода Binary Search (бинарный поиск):**

Binary Search — это эффективный алгоритм поиска элемента в отсортированном массиве или списке, который работает по принципу "разделяй и властвуй". Он сокращает область поиска вдвое на каждом шаге, сравнивая искомое значение с средним элементом текущего диапазона.



**Основные шаги алгоритма:**

1. Изначально установить границы поиска: `low = 0`, `high = n-1`.
2. Вычислить индекс середины: `mid = (low + high) // 2`.
3. Сравнить элемент на позиции `mid` с искомым значением:
   - Если совпадают — вернуть индекс `mid`.
   - Если искомое значение меньше — продолжить поиск в левой половине (`high = mid - 1`).
   - Если больше — в правой половине (`low = mid + 1`).
4. Повторять эти шаги, пока `low <= high`.
5. Если элемент не найден, вернуть отрицательный результат (например, -1).



**Анализ временной сложности:**

- **В худшем, среднем и лучшем случаях:**

На каждом шаге область поиска делится пополам, количество шагов — примерно \( \log_2 n \).

- **Общая сложность:**

\[ T(n) = O(\log n) \]

- **Причина высокой эффективности:**

Бинарный поиск требует значительно меньше сравнений по сравнению с линейным, особенно для больших массивов, только при условии, что массив отсортирован.


**Краткое резюме:**

| Ситуация                     | Временная сложность   |
|------------------------------|----------------------|
| Лучший случай (энлемент в середине), | \( O(1) \) (если сразу найден) |
| Средний и худший случаи       | \( O(\log n) \)       |

---


**Определение метода Interpolation Search (Интерполяционный поиск):**

Interpolation Search — это алгоритм поиска, эффективный в отсортированных равномерных массивах. Он работает по принципу, похожему на "предсказание" положения искомого элемента на основе его значения, что делает его более быстрым, чем бинарный поиск при равномерных данных.


**Основные идеи и шаги алгоритма:**

1. Установить границы поиска: `low = 0`, `high = n - 1`.
2. Вычислить предполагаемый индекс `mid` по формуле:

   \[
   mid = low + \frac{(x - arr[low]) \times (high - low)}{arr[high] - arr[low]}
   \]

   где \( x \) — искомое значение, а `arr[low]`, `arr[high]` — крайние значения текущего диапазона.

3. Сравнить `arr[mid]` с `x`:
   - Если равно — вернуть `mid`.
   - Если меньше — продолжить поиск в правой части (`low = mid + 1`).
   - Если больше — в левой (`high = mid - 1`).
4. Повторять, пока `low <= high` и искомое значение в пределах диапазона.
5. Если элемент не найден, вернуть -1.


**Ключевая особенность:**

- Предполагается, что данные равномерно распределены, что позволяет "предсказать" место искомого элемента.
- В случае нерегулярных или неравномерных данных эффективность снижается.


**Анализ временной сложности:**

- **В среднем и при равномерных данных:**

\[ T(n) = O(\log \log n) \]

— очень быстрый поиск.

- **В худшем случае (например, неравномерное распределение):**

\[ T(n) = O(n) \]

— почти как линейный поиск.


**Краткое резюме:**

| Ситуация                                | Временная сложность     |
|-----------------------------------------|------------------------|
| В среднем (равномерные данные)        | \( O(\log \log n) \)   |
| В худшем (неровномерные, нерегулярные данные) | \( O(n) \)          |

---

**Определение метода Fibonacci Search (фибоначчиева поиск):**

Fibonacci Search — это алгоритм поиска в отсортированном массиве, основанный на использовании чисел Фибоначчи для определения точек разбиения массива. Он работает аналогично бинарному поиску, делая разделения, определяемые числами Фибоначчи, что позволяет эффективно сокращать диапазон поиска.


**Основные идеи и шаги алгоритма:**

1. **Подготовка:**
   - Определить наименьшее число Фибоначчи, которое равно или больше \( n \) (размер массива), обозначим его как \( fibM \).
   - Создать последовательность чисел Фибоначчи: \( fib = [0, 1, 1, 2, 3, 5, 8, 13, 21, ...] \).

2. **Инициализация:**
   - Определить две переменные:
     - `fib2` — предыдущее число Фибоначчи,
     - `fib1` — следующее число, 
   - со значениями: `fib2 = 0`, `fib1 = 1`.

3. **Определение диапазона поиска:**
   - Генерировать последовательность Фибоначчи до тех пор, пока \( fib \) не станет больше или равно \( n \).

4. **Поиск:**
   - Изначально установить индекс `offset = -1`.
   - Пока \( fib \) больше 1:
     - Вычислить индекс `i = min(offset + fib2, n-1)`.
     - Сравнить `arr[i]` с искомым элементом:
       - Если равно — вернуть `i`.
       - Если `arr[i]` меньше — сместить поиск вправо (\( offset = i \)), уменьшить числа Фибоначчи:  
         `fib = fib1`, `fib1 = fib2`, `fib2 = fib - fib1`.
       - Если `arr[i]` больше — уменьшить диапазон слева, сохраняя текущий `offset`.
5. **Проверка последнего элемента:**
   - Если после завершения цикла осталось один элемент, проверить его.
   
6. **Если элемент не найден — вернуть -1.**


**Преимущество:**

- Хорош для больших массивов.
- Работает за \( O(\log n) \), аналогично бинарному поиску, но используя числа Фибоначчи.


**Краткое резюме:**

| Ситуация                     | Временная сложность  |
|------------------------------|---------------------|
| В среднем и худшем случае   | \( O(\log n) \)    |




