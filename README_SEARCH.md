

## Анализ алгоритма: Двоичный поиск (Binary Search)

***Определение:***
Двоичный поиск — это эффективный алгоритм поиска элемента в отсортированном массиве. Он последовательно делит диапазон поиска пополам, пока не найдёт искомый элемент или не установит, что его нет.


***В худшем случае:***

- В худшем случае, искомый элемент отсутствует в массиве или находится в самом конце.
- Количество итераций (разделений) равно примерно \( \log_2 n \).

***Какие циклы влияют на временную сложность?***

**Основной цикл:**

```python
left = 0
right = n - 1
while left <= right:
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
```

- В этом цикле за each итерацию \( left \) или \( right \) сдвигаются примерно в два раза, уменьшая диапазон поиска.

***Влияние циклов на сложность:***

- Каждая итерация цикла делит действительный размер массива (отрезка) пополам.
- Максимальное число итераций — \( \log_2 n \), так как после каждого шага количество элементов в диапазоне уменьшается вдвое.

***Итоговая сложность:***

\[
\boxed{O(\log n)}
\]

- В худшем случае, чтобы определить есть ли искомый элемент или нет, потребуется не более \( \log_2 n \) итераций.


---


## Анализ алгоритма: Поиск Фибоначчи (Fibonacci Search)

***Определение:***
Поиск Фибоначчи — это метод поиска в отсортированном массиве, похожий на двоичный поиск, но он использует последовательность Фибоначчи для определения точек деления массива вместо деления пополам.


***В худшем случае:***

- Алгоритм делит массив с помощью предопределенной последовательности Фибоначчи.
- В худшем случае, аналогично двоичному поиску, алгоритм работает за \( O(\log n) \).

***Какие циклы влияют на сложность?***

**Основные циклы:**

1. **Генерация последовательности Фибоначчи:**

```python
fibMMm2 = 0  # (m-2)-й член
fibMMm1 = 1  # (m-1)-й член
fibM = fibMMm2 + fibMMm1  # m-й член

while fibM < n:
    fibMMm2 = fibMMm1
    fibMMm1 = fibM
    fibM = fibMMm2 + fibMMm1
```

- Этот цикл определяет минимальную длину последовательности Фибоначчи, превышающую размер массива.
- Он выполняется примерно \( O(\log n) \) раз, поскольку Fibonacci числа растут экспоненциально.

2. **Процесс поиска:**

```python
offset = -1

while fibM > 1:
    i = min(offset + fibMMm2, n-1)
    if arr[i] < target:
        fibM = fibMMm1
        fibMMm1 = fibMMm2
        fibMMm2 = fibM - fibMMm1
        offset = i
    elif arr[i] > target:
        fibM = fibMMm2
        fibMMm1 = fibMMm1 - fibMMm2
        fibMMm2 = fibM - fibMMm1
    else:
        return i
```

- Этот цикл сравнивает элемент массива с целевым и уменьшает диапазон поиска, используя числа Fibonacci.
- Количество итераций — \( O(\log n) \), поскольку каждое условие уменьшает диапазон аналогично двоичной, только с другими пропорциями.

***Итог:***

- Вычисление последовательности Fibonacci — \( O(\log n) \).
- Основной цикл поиска также — \( O(\log n) \).

**Общая временная (худшая) сложность:**

\[
\boxed{O(\log n)}
\]

Это делает поиск Фибоначчи очень похожим по эффективности на двоичный поиск, но использующим последовательность чисел Фибоначчи для деления диапазона.
\

---


## Анализ цикла интерполяционного поиска

1. **Проверка условий продолжения цикла:**
   - Истекает ли диапазон поиска (low ≤ high).
   - Находится ли целевой элемент внутри текущего диапазона (target ≥ arr[low] и target ≤ arr[high]).

2. **Вычисление предполагаемой позиции:**
   - На основе значений элементов на границах диапазона и целевого элемента делается оценка предполагаемой позиции поиска (с помощью формулы, основанной на пропорции между значениями).  
   - В худшем случае, если распределение данных неравномерное или все элементы равны, вычисленная позиция может почти не изменяться или приводить к одному и тому же месту.

3. **Проверка элемента на позиции:**
   - Если элемент равен целевому, поиск завершен.
   - Если элемент меньше целевого, граница поиска смещается вправо; `low` увеличивается.
   - Если больше — смещается влево; `high` уменьшается.

4. **Обновление диапазона:**
   - В зависимости от сравнения обновляется граница массива (`low` или `high`), чтобы сузить поиск.

5. **Повторение цикла:**
   - Действия повторяются, пока условия не перестанут выполняться либо не найдете искомый элемент.


***В худшем случае:***

- **На каждом этапе** обновления границ диапазона **минимально** или **совсем не уменьшаются**, особенно если:
  - элементы равны, и вычисленная позиция не сокращает диапазон.
  - распределение элементов не соответствует предположениям (например, неравномерно расположены).

- **Результат:**  
  - Цикл выполняется почти бесконечно или до тех пор, пока не пройдут все элементы массива.


## Итоговая временная сложность по этапам:

- **Количество итераций цикла в худшем случае:** \(\boxed{\text{O}(n)}\).  
- Т.е., цикл может пройти через все элементы массива, что делает алгоритм линейным по времени в худших сценариях.

---



## Анализ линейного поиска 

***Поэтапные действия цикла:***

1. **Начальная установка:**
   - Начинается с первого элемента массива (или текущего индекса в цикле).

2. **Проверка текущего элемента:**
   - Сравнивается текущий элемент с искомым.
   - Если элементы совпадают, поиск завершен — возвращается индекс найденного элемента.

3. **Переход к следующему элементу:**
   - Если элементы не совпадают, перейти к следующему элементу массива (увеличить индекс на 1).

4. **Повторение:**
   - Шаги 2 и 3 повторяются для каждого следующего элемента, пока не будет найден искомый элемент или не будут просмотрены все элементы.

5. **Завершение:**
   - Если достигнут конец массива и искомый элемент не найден — возвращается сигнал о отсутствии элемента (например, -1).


## В худшем случае:

- **Элемент отсутствует в массиве или находится в самом конце.**
- **Цикл проверяет каждый элемент по порядку**, начиная с первого и заканчивая последним.

***Итоговая временная сложность в худшем случае:***

\[
\boxed{O(n)}
\]

где \( n \) — размер массива.  
- Особенно, если искомый элемент отсутствует или находится в конце массива, потребуется проверить все элементы.

