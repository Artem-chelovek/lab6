# Понятие дерева и графа
**Определение дерева**
Дерево — это связный ациклический граф, состоящий из конечного числа вершин и ребер, где между любыми двумя вершинами существует единственный путь. Характеристики дерева:

Одна выделенная вершина называется корнем.
Ребра направлены от корня к листьям (вершинам без выходящих ребер).
Каждая вершина имеет ровно одно входящее ребро, кроме корня, у которого входящих ребер нет.
Примером дерева является структура каталогов файлов на компьютере или семейное древо.

**Определение графа**
Граф — это математический объект, состоящий из множества вершин (точек) и множества ребер (связей между вершинами). Граф может быть:

Ориентированным (ребра имеют направление) или неориентированным (нет направления).
Весовым (каждое ребро имеет вес или длину) или невесомым.
Примерами графов служат социальные сети, схемы дорог или электрические цепи.

# Формирование деревьев и графов на Python, Java и C++
**Пример формирования дерева на Python**

`class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []

    def add_child(self, child):
        self.children.append(child)

#Пример использования**
root = TreeNode(1)
root.add_child(TreeNode(2))
root.add_child(TreeNode(3))`

***Анализ:***

В классе TreeNode каждая вершина сохраняет свое значение и список дочерних вершин. Создание дерева простое и интуитивное, его можно расширить дополнительными функциями для обхода и манипуляции.

# Пример формирования графа на Java

`import java.util.ArrayList;
import java.util.List;

class GraphVertex {
    int id;
    List<GraphVertex> neighbors;

    public GraphVertex(int id) {
        this.id = id;
        this.neighbors = new ArrayList<>();
    }

    public void addNeighbor(GraphVertex vertex) {
        neighbors.add(vertex);
    }
}

// Пример использования
GraphVertex A = new GraphVertex(1);
GraphVertex B = new GraphVertex(2);
A.addNeighbor(B);
B.addNeighbor(A);`

***Анализ:***

Граф представлен списком вершин, каждая из которых хранит список своих соседей. Такое представление называют списком смежности. Удобно для динамических изменений графа и достаточно компактно по памяти.

# Пример формирования графа на C++

`#include <iostream>
#include <vector>

using namespace std;

class Vertex {
public:
    int id;
    vector<Vertex*> neighbors;

    Vertex(int id) : id(id) {}

    void addNeighbor(Vertex* neighbor) {
        neighbors.push_back(neighbor);
    }
};

// Пример использования
int main() {
    Vertex A(1), B(2);
    A.addNeighbor(&B);
    B.addNeighbor(&A);
    return 0;
}`
***Анализ:***

Код аналогичный примеру на Java, разница в том, что в C++ используется указатель на объекты класса Vertex, что повышает производительность и снижает потребление памяти.

# Пошаговый анализ работы алгоритма обхода дерева (DFS)
Рассмотрим алгоритм глубинного поиска (Depth First Search, DFS) на примере дерева, написанный на Python.


`def dfs(node):
    visited = set()
    stack = [node]

    while stack:
        current = stack.pop()
        if current not in visited:
            visited.add(current)
            print(current.value)
            stack.extend(reversed(current.children))

# Пример использования
dfs(root)`


***Шаг 1.*** Начало работы алгоритма:
Начинаем с корня дерева (root).
Текущие посещённые вершины сохраняются в множестве visited.
Очередь стека (stack) инициализируется с первой вершиной.

***Шаг 2.*** Пока стэк не пуст:
Извлекаем вершину из верхней части стека.
Если вершина ещё не была посещена, добавляем её в множество посещенных и выводим её значение.
Добавляем в стэк всех её необработанных детей (обратите внимание на обратную последовательность добавления, чтобы сохранить правильный порядок обхода).

# Оценка временной сложности:
Посещение каждой вершины происходит ровно один раз.
Каждый ребро также рассматривается один раз при переходе от родителя к ребёнку.
Общая временная сложность алгоритма DFS для дерева с N вершинами и E рёбрами:O(N+E).
