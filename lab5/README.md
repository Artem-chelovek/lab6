# Вариант 5. Напишите рекурсивную функцию для проверки, является ли строка палиндромом.
# Описание алгоритма с синтаксисом на языке Python
1. Функция `is_palindrome`
Это рекурсивная функция, принимающая одну аргумента — строку s. Она возвращает булево значение (`True` или `False`), которое показывает, является ли переданная строка палиндромом.
Параметры:
s: Строка, которую мы хотим проверить на симметричность относительно своего центра.

2. Базовый случай рекурсии
Первым делом выполняется проверка длины строки:
```
if len(s) <= 1:
   return True
```
Описание:Строки длиной 0 или 1 являются палиндромами по определению. Поэтому, если строка либо пустая, либо состоит всего из одного символа, функция немедленно возвращает `True`.

3. Основная логика рекурсии
Если базовый случай не выполнен, начинается сравнение первого и последнего символов строки:
```
elif s[0].lower() == s[-1].lower():
   return is_palindrome(s[1:-1])
```
Описание:  
Первый символ строки извлекается как `s[0]`, а последний — как `s[-1]`.
Чтобы сделать алгоритм нечувствительным к регистру букв, используется метод `.lower()`, который преобразует обе буквы в нижний регистр.
Если первый и последний символы совпадают, запускается рекурсивный вызов функции, передавая ей новую строку, в которой исключены первый и последний символы `s[1:-1]`.

4. Обработка неудачного сравнения
Если первая и последняя буквы строки отличаются, строка не является палиндромом, и функция возвращает `False`:
```
else:
    return False
```
# Описание алгоритма с синтаксисом на языке Java
Импортирование необходимых классов

`import java.util.Scanner;`
Библиотека Scanner необходима для чтения ввода с клавиатуры.
2. Класс и метод main

`public class PalindromeChecker { /*...*/ }`
Основной класс называется `PalindromeChecker`, содержащий точку входа приложения — метод `main`.
```
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    System.out.print("Введите строку: ");
    String input = scanner.nextLine();
    
    boolean result = isPalindrome(input);
    
    if (result)
        System.out.println("Строка является палиндромом.");
    else
        System.out.println("Строка не является палиндромом.");
        
    scanner.close(); // Обязательно закрываем ресурс
}
```
Создаётся объект класса Scanner, который считывает строку с консоли.
После обработки результата рекурсивной функции выдаётся соответствующее сообщение.
Ресурс scanner обязательно закрывается для освобождения памяти.
3. Рекурсивная функция `isPalindrome`
```
private static boolean isPalindrome(String str) {
    if (str.length() <= 1)
        return true;

    char firstChar = Character.toLowerCase(str.charAt(0));
    char lastChar = Character.toLowerCase(str.charAt(str.length() - 1));

    if (firstChar == lastChar)
        return isPalindrome(str.substring(1, str.length() - 1));
    else
        return false;
}
```
Входной аргумент: строка `str`, которую мы будем проверять.
Базовый случай: если строка пустой или односимвольной, это автоматически считается палиндромом.
Преобразование к нижнему регистру: используются методы `Character.toLowerCase()` для устранения влияния регистра символов.
Основная логика: если первый и последний символы совпадают, делаем рекурсивный вызов с обрезанной строкой, удаляя первый и последний символы.
Если символы не совпадают, строка не является палиндромом, и функция возвращает `false`.

# Временная сложность и ее анализ
Временная сложность - O(n)

Что влияет на временную сложность:
1. Длина строки (n):
Каждый рекурсивный вызов уменьшает длину строки на два символа.
2. Операции с каждым вызовом:
Получение первого и последнего символов занимает постоянное время O(1).
Приведение символов к нижнему регистру также занимает постоянное время O(1).
Создание подстроки (при вызове `substring())` требует линейного времени по количеству символов, включённых в новую строку. Однако, поскольку на каждом уровне рекурсии подстрока становится короче на два символа, общая стоимость создания подстрок тоже пропорциональна общей длине строки.

Таким образом, каждая операция, связанная с созданием подстроки, добавляет дополнительную нагрузку порядка O(n), однако это происходит лишь один раз за весь процесс рекурсии.

# Ответ на контрольный вопрос
В чем суть алгоритма backtracking?

Backtracking — это метод решения задач путем систематического перебора всех возможных
вариантов решения. Алгоритм строит решение пошагово и откатывается назад (backtrack),
когда обнаруживает, что текущий путь не приведет к решению.
